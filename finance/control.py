# !/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Mar 12 15:37:47 2019

@author: python
"""
from abc import ABC, abstractmethod
from logging import log
from error.errors import ZiplineError

__all__ = [
    'MaxOrderSize',
    'MaxPositionSize',
    'LongOnly'
]


class TradingControlViolation(ZiplineError):
    """
    Raised if an order would violate a constraint set by a TradingControl.
    --- used for blotter which in nakedquant transaction module
    """
    msg = """
            Order for {amount} shares of {asset} at {datetime} violates trading constraint
            {constraint}.
        """.strip()


class TradingControl(ABC):
    """ 针对于买入标的，对于卖出没有过多控制
    Abstract base class representing a fail-safe control on the behavior of any
    algorithm.
    a. 单一持仓比率不能超过60%
    b. 持仓数量ST --- 50万股
    c. 不能卖空
    """
    def __init__(self, on_error, **kwargs):
        """
        Track any arguments that should be printed in the error message
        generated by self.fail.
        """
        self.on_error = on_error
        self.__fail_args = kwargs

    @abstractmethod
    def validate(self,
                 asset,
                 amount,
                 portfolio,
                 algo_datetime):
        """
        Before any order is executed by TradingAlgorithm, this method should be
        called *exactly once* on each registered TradingControl object.

        If the specified asset and amount do not violate this TradingControl's
        restraint given the information in `portfolio`, this method should
        return None and have no externally-visible side-effects.

        If the desired order violates this TradingControl's contraint, this
        method should call self.fail(asset, amount).
        """
        raise NotImplementedError

    def handle_violation(self, asset, amount, date_time):
        """
        Handle a TradingControlViolation, either by raising or logging and
        error with information about the failure.

        If dynamic information should be displayed as well, pass it in via
        `metadata`.
        """
        constraint = repr(self)

        if self.on_error == 'fail':
            raise TradingControlViolation(
                asset=asset,
                amount=amount,
                datetime=date_time,
                constraint=constraint)
        elif self.on_error == 'log':
            log.error("Order for {amount} shares of {asset} at {dt} "
                      "violates trading constraint {constraint}",
                      amount=amount, asset=asset, dt=date_time,
                      constraint=constraint)

    def __repr__(self):
        return "{name}({attrs})".format(name=self.__class__.__name__,
                                        attrs=self.__fail_args)


class MaxOrderSize(TradingControl):
    """
    TradingControl representing a limit on the magnitude of any single order
    placed with the given asset.  Can be specified by share or by dollar
    value.
    深圳ST股票买入卖出都不受限制，上海买入限制50万股，卖出没有限制
    """
    name = 'MaxOrderSize'

    def __init__(self, max_shares=500000, on_error='fail'):
        super(MaxOrderSize, self).__init__(on_error,
                                           max_shares=max_shares)
        self.max_shares = max_shares

        if max_shares and max_shares < 0:
            raise ValueError(
                "max_shares cannot be negative."
            )

    def validate(self,
                 asset,
                 amount,
                 portfolio,
                 algo_datetime):
        """
        Fail if the magnitude of the given order exceeds either self.max_shares
        or self.max_notional.
        """
        status = asset.is_specialized(algo_datetime)
        if status and asset.sid.startswith('6'):
            return min(self.max_shares, amount)
        return amount


class MaxPositionSize(TradingControl):
    """
    TradingControl representing a limit on the maximum position size that can
    be held by an algo for a given asset.
    e.g 单一持仓不超过0.6
    """
    name = 'MaxPositionSize'

    def __init__(self, max_notional=0.6, on_error='fail'):
        super(MaxPositionSize, self).__init__(on_error,
                                              max_notional=max_notional)
        self.max_notional = max_notional

        if max_notional and max_notional < 0:
            raise ValueError(
                "max_notional must be positive."
            )

    def validate(self,
                 asset,
                 amount,
                 portfolio,
                 algo_datetime):
        """
        Fail if the given order would cause the magnitude of our position to be
        greater in shares than self.max_shares or greater in dollar value than
        self.max_notional.
        """

        if self.asset is not None and self.asset != asset:
            return

        max_value = portfolio.portfolio_value * self.max_notional
        # 已有持仓
        # 不同的策略生成相同的标的 --- sid
        position = [p for p in portfolio.positions if p.sid == asset.sid]
        holding_value = sum([p.amount * p.last_sync_price for p in position])
        available_capital = max_value - holding_value
        return available_capital


class LongOnly(TradingControl):
    """
    TradingControl representing a prohibition against holding short positions.
    """
    name = 'LongOnly'

    def __init__(self, on_error):
        super(LongOnly, self).__init__(on_error)

    def validate(self,
                 asset,
                 amount,
                 portfolio,
                 algo_datetime):
        """
        Fail if we would hold negative shares of asset after completing this
        order.
        """
        holding_amount = sum([p.amount for p in portfolio.positions if p.sid == asset.sid])
        if holding_amount + amount < 0:
            self.handle_violation(asset, amount, algo_datetime)


if __name__ == '__main__':

    control = MaxOrderSize()
    print('control', control)
